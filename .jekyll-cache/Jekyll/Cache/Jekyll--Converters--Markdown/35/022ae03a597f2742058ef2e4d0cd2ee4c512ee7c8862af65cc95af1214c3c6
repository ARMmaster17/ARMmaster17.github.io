I"ºE<p>A while back, I wrote <a href="https://github.com/ARMmaster17/JeffBot">Jeffbot</a> as a fun side project because I was bored between classes in college. JeffBot is simply a chatbot with the intelligence of a two-year-old. It learns words and what words can/can‚Äôt be used sequentially in a sentence. At first, it spews out pure garbage or just repeats back what you just said. However, over time, JeffBot learns how to make what appears to be intelligent english.</p>

<p>JeffBot itself is a complex app split over three different Heroku dynos and a particularly large database running on top of Rails/Sinatra/ASP.NET/I‚Äôm not even sure what anymore. In this article, I‚Äôm going to show you how to rebuild an N2 version of JeffBot in pure Ruby that can run locally with no external service/library dependencies.</p>

<p>First, you will need to set up a directory for JeffBot. Create a directory called <code class="highlighter-rouge">JeffBot</code> and <code class="highlighter-rouge">cd</code> into it. From now on, this directory will be referred to as <code class="highlighter-rouge">~/</code>. Inside this directory, create a file called <code class="highlighter-rouge">main.rb</code> and paste this code in.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="c1"># ~/main.rb</span>

<span class="k">def</span> <span class="nf">learn</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">training_data</span><span class="p">)</span>
    <span class="n">grams</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">).</span><span class="nf">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">to_a</span>
    <span class="n">grams</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">gram</span><span class="o">|</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="n">training_data</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span> <span class="n">entry</span><span class="p">.</span><span class="nf">w1</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">gram</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">.</span><span class="nf">w2</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">gram</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">}</span>
        <span class="k">if</span> <span class="n">entries</span><span class="p">.</span><span class="nf">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entries</span><span class="p">.</span><span class="nf">nil?</span>
            <span class="n">training_data</span> <span class="o">&lt;&lt;</span> <span class="no">Struct</span><span class="o">::</span><span class="no">Ngram</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">gram</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gram</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="n">entries</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">respond</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">training_data</span><span class="p">)</span>
    <span class="n">word</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">" "</span><span class="p">).</span><span class="nf">sample</span>
    <span class="n">sentence</span> <span class="o">=</span> <span class="n">word</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="n">training_data</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span> <span class="n">entry</span><span class="p">.</span><span class="nf">w1</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">if</span> <span class="n">entries</span><span class="p">.</span><span class="nf">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entries</span><span class="p">.</span><span class="nf">nil?</span>
            <span class="n">sentence</span> <span class="o">&lt;&lt;</span> <span class="s2">"."</span>
            <span class="k">break</span>
        <span class="k">else</span>
            <span class="n">new_word</span> <span class="o">=</span> <span class="n">entries</span><span class="p">.</span><span class="nf">sample</span><span class="p">.</span><span class="nf">w2</span>
            <span class="n">sentence</span> <span class="o">&lt;&lt;</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">new_word</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">new_word</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">sentence</span>
<span class="k">end</span>

<span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Ngram"</span><span class="p">,</span> <span class="ss">:w1</span><span class="p">,</span> <span class="ss">:w2</span><span class="p">,</span> <span class="ss">:count</span><span class="p">)</span>

<span class="n">learning_data</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">while</span> <span class="kp">true</span>
    <span class="nb">print</span> <span class="s2">"&gt;"</span>
    <span class="n">input</span> <span class="o">=</span> <span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span>
    <span class="k">if</span> <span class="n">input</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="s2">"exit"</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">learn</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">learning_data</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">respond</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">learning_data</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let‚Äôs go through this code block by block to see what it does. Let‚Äôs start in the same place that the interpreter starts, line 32. This defines a struct called an N-gram. This represents a relationship between how likely one word is to appear after another. Take a look at the following input string:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is a sentence.
</code></pre></div></div>

<p>Our <code class="highlighter-rouge">learn()</code> function that we are going to cover in a minute is going to split that sentence into 2n N-grams like so.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[This, is]
[is, a]
[a, sentence]
</code></pre></div></div>

<p>Assuming this is the only training data provided, if we start with ‚Äúa‚Äù, our chatbot would choose ‚Äúsentence‚Äù as the next word. If multiple relations exist for one word, a random selection is made based on the choices (utilizing the <code class="highlighter-rouge">count</code> attribute is left as an exercise for the reader).</p>

<p>The remainder of the code creates a <code class="highlighter-rouge">learning_data[]</code> array that we use to store training data. It also provides a loop to take input from the user, and exit the application if they have requested to do so by typing ‚Äúexit‚Äù at the prompt. Towards the bottom of the code block, we see calls to <code class="highlighter-rouge">learn()</code> and <code class="highlighter-rouge">respond()</code>. These two methods form the backbone logic of our chatbot.</p>

<p>Now let‚Äôs take a look at the <code class="highlighter-rouge">learn()</code> method. We call it with two parameters, <code class="highlighter-rouge">input</code> and <code class="highlighter-rouge">training_data[]</code>. The first thing we need to do is convert <code class="highlighter-rouge">input</code> into a series of 2N-grams like so.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">grams</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">' '</span><span class="p">).</span><span class="nf">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">to_a</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Next we iterate over the list of <code class="highlighter-rouge">grams</code>, with <code class="highlighter-rouge">gram</code> representing the relation we are currently looking at.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">entries</span> <span class="o">=</span> <span class="n">training_data</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span> <span class="n">entry</span><span class="p">.</span><span class="nf">w1</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">gram</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">.</span><span class="nf">w2</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">gram</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This line pulls out an N-gram relation if it already exists in our training data where both the first word and the second word match in the <code class="highlighter-rouge">gram</code> we are currently looking at.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">if</span> <span class="n">entries</span><span class="p">.</span><span class="nf">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entries</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="n">training_data</span> <span class="o">&lt;&lt;</span> <span class="no">Struct</span><span class="o">::</span><span class="no">Ngram</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">gram</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gram</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">else</span>
    <span class="n">entries</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This <code class="highlighter-rouge">if</code> block runs some logic on the results from the previous query of <code class="highlighter-rouge">training_data[]</code>. If a relation already exists, we increment the count. Otherwise we create a new <code class="highlighter-rouge">Ngram</code> Struct and shove it into <code class="highlighter-rouge">training_data[]</code>.</p>

<p>Now let‚Äôs move on to the <code class="highlighter-rouge">respond()</code> method. We call this with the same parameters as <code class="highlighter-rouge">learn()</code>. Our first line picks the first word based on the words that the user wrote at the prompt. We use this word to start our <code class="highlighter-rouge">sentence</code> and to initialize <code class="highlighter-rouge">word</code> that we will utilize in a loop.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>    <span class="n">word</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">" "</span><span class="p">).</span><span class="nf">sample</span>
    <span class="n">sentence</span> <span class="o">=</span> <span class="n">word</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Next we enter a <code class="highlighter-rouge">for</code> loop. I set an arbitrary limit of 12 words in a sentence, you can increment this by increasing the range that the <code class="highlighter-rouge">for</code> loop iterates over.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">entries</span> <span class="o">=</span> <span class="n">training_data</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span> <span class="n">entry</span><span class="p">.</span><span class="nf">w1</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Within this <code class="highlighter-rouge">for</code> loop, we use similar logic from the <code class="highlighter-rouge">learn()</code> method. The difference is that we only have the first part of the N-gram (<code class="highlighter-rouge">w1</code>). If the number of matchine entries is zero, we add a period to the sentence and return it to the prompt loop.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">if</span> <span class="n">entries</span><span class="p">.</span><span class="nf">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">entries</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="n">sentence</span> <span class="o">&lt;&lt;</span> <span class="s2">"."</span>
    <span class="k">break</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If matches are found, we assign it to <code class="highlighter-rouge">new_word</code>. Then we add it to <code class="highlighter-rouge">sentence</code> and move it to <code class="highlighter-rouge">word</code> so we can use it as our new <code class="highlighter-rouge">w1</code> on the next loop iteration.</p>

<p>That‚Äôs all there is to it. Run it by <code class="highlighter-rouge">cd</code>-ing into your project directory and running <code class="highlighter-rouge">ruby ./main.rb</code> from the terminal. When you recieve the <code class="highlighter-rouge">&gt;</code> prompt, enter a string of words. Your new chatbot should reply back with some garbage. Talk with it some more, the more input you provide, the faster it can learn and respond with some more intelligent-sounding english.</p>

<p>To quit, just type ‚Äúexit‚Äù at the <code class="highlighter-rouge">&gt;</code> prompt. Note that learning data is stored in memory. This means that when you quit, all training data is lost. When you run the program again, you are starting with a fresh slate. For more permanent storage, take a look at the <code class="highlighter-rouge">pg</code> ruby gem paired with the PostgreSQL database service.</p>
:ET